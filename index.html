<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Game</title>
    <style>
        canvas{
            background-color: black;
        }

        #add-ball{
            position:absolute;
            top: 10px;
            right: 10px;
            background-color: blueviolet;
            padding: 10px;
            cursor: pointer;
        }
    </style>
</head>

<body>
<canvas id="gameCanvas" width="800" height="800"></canvas>
<div  id="add-ball">Add ball</div>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');       //creatCircle, createRectangle, createTriangle, createLine

const DECIMAL_MULTIPLIER = 1000;

/*Constants*/

const WIDTH = 800;
const HEIGHT = 800;
const ballRadius = 7;
const obstacleRadius = 4; //less than ball
const gravity = pad(0.2);  //reasonable choice of gravity after trying few(not considering time so no g=9.8)
const horizontalFriction = 0.4;
const verticalFriction = 0.8;
let balls = [];  //stores the  balls that are falling

const obstacles = [];  //stores the obstacles present in current state of game
const sinks = [];  //the sinks where ball reaches in the end

//padding function to avoid getting the decimals(avoiding precision error)
function pad(n)
{
return n*DECIMAL_MULTIPLIER;
}

//unpad function
function unpad(n)
{
    return Math.floor(n/DECIMAL_MULTIPLIER);
}

//Creating a obstacle pyramid
const rows = 16;
for(let row=2;row<rows;row++)
{ 
const numOfObstacles = rows+1;  //like row=2 will be 3
const y = 0 + rows*35;
const spacing = 36;   //picked spacing based on some hit n trial
for(let col = 0; col<numOfObstacles;col++)
{
const x = WIDTH/2 - spacing * (row/2 - col);  //formulae to place obstacles
obstacles.push({x : pad(x), y : pad(y), radius : obstacleRadius});  //pushing obstacle obj in array
}
}

//Create sinks at the bottom of the rectangle
const sinkWidth = 36;
const NUM_SINKS = 15;

for(let i=0;i<NUM_SINKS;i++)
{
    const x =  (WIDTH/2) + (i-15/2)*(sinkWidth) + (obstacleRadius);   //obstacleRadius for slight padding  
    const y =  HEIGHT - 240;   
    const width  = sinkWidth;
    const height =  width;
    sinks.push({x,y,width,height});
}

//obstacles, sink
//Encapsulating the code
class Ball{

    constructor(x,y,radius,color)
    {
this.x = x;
this.y = y;
this.radius = radius;
this.vx = 0;
this.vy = 0;
    }

 draw() {
    ctx.beginPath();
    ctx.arc(unpad(this.x),this.unpad(y),this.radius, 0, Math.PI*2);
    ctx.fillStyle = this.color;
    ctx.fill();
    ctx.closePath();
}

//Updating the velocities and positions as the game proceeds
update(){
    //change the velocity and position
    this.vy+=gravity;  //gravity only in y direction
    this.x+=vx;   
    this.y+=vy;

    //Collisons with obstacles
    obstacles.forEach(obstacle => {
const dist = Math.hypot(this.x - obstacle.x, this.y - obstacle.y);

if(dist < pad(this.radius + obstacle.radius))
{
//Calculate the angle of coollison
const angle = Math.atan2(this.y - obstacle.y, this.x - obstacle.x);

    //Reflect the velocities
    const speed = Math.sqrt((this.x*this.x) + (this.y*this.y));
    this.vx = (Math.cos(angle)*speed*horizontalFriction);
    this.vy = (Math.sin(angle)*speed*verticalFriction);

    //Adjusting the positioning to prevent sticking
    const overlap  = this.radius + obstacle.radius - unpad(dist);
    this.x += pad(Math.cos(angle)*overlap);
    this.y += pad(Math.sin(angle)*overlap);

}
    })
}

}
    
</script>    
</body>
</html>