<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Game</title>
    <style>
        canvas{
            background-color: black;
        }

        #add-ball{
            position:absolute;
            top: 10px;
            right: 10px;
            background-color: blueviolet;
            padding: 10px;
            cursor: pointer;
        }
    </style>
</head>

<body>
<canvas id="gameCanvas" width="800" height="800"></canvas>
<div  id="add-ball">Add ball</div>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');       //creatCircle, createRectangle, createTriangle, createLine

const DECIMAL_MULTIPLIER = 1000;

/*Constants*/

const WIDTH = 800;
const HEIGHT = 800;
const ballRadius = 7;
const obstacleRadius = 4; //less than ball
const gravity = pad(0.2);  //reasonable choice of gravity after trying few(not considering time so no g=9.8)
const horizontalFriction = 0.4;
const verticalFriction = 0.8;
let balls = [];  //stores the  balls that are falling

const obstacles = [];  //stores the obstacles present in current state of game
const sinks = [];  //the sinks where ball reaches in the end

//padding function to avoid getting the decimals(avoiding precision error)
function pad(n)
{
return n*DECIMAL_MULTIPLIER;
}

//unpad function
function unpad(n)
{
    return Math.floor(n/DECIMAL_MULTIPLIER);
}

//Creating a obstacle pyramid
const rows = 16;
for(let row=2;row<rows;row++)
{ 
const numOfObstacles = rows+1;  //like row=2 will be 3
const y = 0 + rows*35;
const spacing = 36;   //picked spacing based on some hit n trial
for(let col = 0; col<numOfObstacles;col++)
{
const x = WIDTH/2 - spacing * (row/2 - col);  //formulae to place obstacles
obstacles.push({x : pad(x), y : pad(y), radius : obstacleRadius});  //pushing obstacle obj in array
}
}

//Create sinks at the bottom of the rectangle
const sinkWidth = 36;
const NUM_SINKS = 15;

for(let i=0;i<NUM_SINKS;i++)
{
    const x =  (WIDTH/2) + (i-15/2)*(sinkWidth) + (obstacleRadius);   //obstacleRadius for slight padding  
    const y =  HEIGHT - 240;   
    const width  = sinkWidth;
    const height =  width;
    sinks.push({x,y,width,height});
}

//obstacles, sink
//Encapsulating the code
class Ball{

    constructor(x,y,radius,color)
    {
this.x = x;
this.y = y;
this.radius = radius;
this.vx = 0;
this.vy = 0;
    }

 draw() {
    ctx.beginPath();
    ctx.arc(unpad(this.x),this.unpad(y),this.radius, 0, Math.PI*2);
    ctx.fillStyle = this.color;
    ctx.fill();
    ctx.closePath();
}

//Updating the velocities and positions as the game proceeds
update(){
    //change the velocity and position
    this.vy+=gravity;  //gravity only in y direction
    this.x+=vx;   
    this.y+=vy;

    //Collisons with obstacles
    obstacles.forEach(obstacle => {
const dist = Math.hypot(this.x - obstacle.x, this.y - obstacle.y);

if(dist < pad(this.radius + obstacle.radius))
{
//Calculate the angle of coollison
const angle = Math.atan2(this.y - obstacle.y, this.x - obstacle.x);

    //Reflect the velocities
    const speed = Math.sqrt((this.x*this.x) + (this.y*this.y));
    this.vx = (Math.cos(angle)*speed*horizontalFriction);
    this.vy = (Math.sin(angle)*speed*verticalFriction);

    //Adjusting the positioning to prevent sticking
    const overlap  = this.radius + obstacle.radius - unpad(dist);
    this.x += pad(Math.cos(angle)*overlap);
    this.y += pad(Math.sin(angle)*overlap);
}
    });

    //Collisions with the sinks
    sinks.forEach(sink => {
     //It should be between the sinks 
        if(
            unpad(this.x) > sink.x - sink.width/2 &&
            unpad(this.x) < sink.x + sink.width/2 &&
            unpad(this.y) + this.radius > sink.y  - sink.height/2
    )
    //Then slows the ball down and goes out of context
    {
        this.x = 0;
        this.y = 0;
    }
});
    }
}

//instantiates the ball object
const intialBall = new Ball(pad(WIDTH/2 + 23),pad(50), ballRadius, 'red');
balls.push(intialBall);

//Function to render the obstacles
function drawObstacles()
{
    ctx.fillStyle = 'white';

    obstacles.forEach(obstacle => {
ctx.beginPath();
ctx.arc(unpad(obstacle.x),unpad(obstacle.y),obstacle.radius,0,Math.PI*2);
ctx.fill();
ctx.closePath();
    }
);


//Function to render the sinks
function drawSinks()
{
    ctx.fillStyle = 'green';
    for(let i=0;i<sinks.length();i++)
{
const sink = sinks[i];
ctx.fillRect(sink.x, sink.y - sink.height/2, sink.width - obstacleRadius*2, sink.height);
}
}
}

//Function to add a new ball
function addBall()
{
    const newBall = new Ball(pad(WIDTH/2 + 13), pad(50), ballRadius, 'red');
    balls.push(newBall);
}

document.getElementById('add-ball').addEventListener('click',addBall);  //Instantiating a ball when the Add Ball button clicked

function draw()
{
    ctx.clearRect(0,0,WIDTH,HEIGHT);
    drawObstacles();
    drawSinks();
    ball.forEach(ball => {
        ball.draw();
        ball.update();
    });
}

function update()
{
    draw();
    requestAnimationFrame(update);
}

update();

    
</script>    
</body>
</html>